<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <template v-if="isShown">
        <div class="row">
            <div class="col-sm-offset-8 col-sm-4 fee-configure-payment-plan">
                <RockButton btnType="default" btnSize="xs" @click="isModalShown = true">Configure a Payment Plan</RockButton>
            </div>
        </div>

        <Modal v-model="isModalShown"
               saveText="Select"
               title="Configure Payment Plan"
               @save="isModalShown = false">
            <template v-if="paymentDeadlineDate">
                The total amount of {{ formatCurrency(totalAmount, registrationEntryState.viewModel.currencyInfo) }} is payable by {{ paymentDeadlineDate.toASPString("MMMM dd, yyyy") }}.
            </template>
            <template v-else>
                The total amount due is {{ formatCurrency(totalAmount, registrationEntryState.viewModel.currencyInfo) }}.
            </template>
            <div class="row">
                <div class="col">
                    <DropDownList v-model="paymentFrequencyGuid"
                                  :items="paymentFrequencyItems"
                                  label="Select Your Desired Payment Frequency" />
                </div>
            </div>

            <template v-if="paymentFrequencyGuid">
                <div class="row">
                    <div class="col-sm-6">
                        <CurrencyBox v-model="desiredAmountToPayToday"
                                     label="Amount To Pay Today"
                                     :rules="validateAmountToPayTodayRule">
                            <template #append>
                                <small>A minimum of {{ formatCurrency(minimumRemainingAmount, registrationEntryState.viewModel.currencyInfo) }} is due today.</small>
                            </template>
                        </CurrencyBox>
                    </div>

                    <div class="col-sm-6">
                        <DropDownList v-model="numberOfPayments"
                                      :items="numberOfPaymentsItems"
                                      label="Number of Payments" />
                    </div>
                </div>

                <div class="row">
                    <div class="col">
                        <RockLabel label="Plan Summary">Plan Summary</RockLabel>
                    </div>
                </div>

                <div class="row">
                    <div class="col-sm-6">
                        <div>Amount Due Today</div>
                        <div>{{ actualAmountDueTodayMessage }}</div>
                    </div>

                    <div class="col-sm-6">
                        <div>Weekly Payment Amount</div>
                        <div>{{ formatCurrency(amountPerPayment, registrationEntryState.viewModel.currencyInfo) }} x {{ numberOfPaymentsAsNumber }}</div>
                    </div>
                </div>
            </template>
        </Modal>
    </template>
</template>

<script setup lang="ts">
    import { computed, nextTick, ref, watch } from "vue";
    import CurrencyBox from "@Obsidian/Controls/currencyBox.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import Modal from "@Obsidian/Controls/modal.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import RockLabel from "@Obsidian/Controls/rockLabel.obs";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { CurrentRegistrationEntryState, RegistrationCostSummary, TransactionFrequency, formatCurrency, getTransactionFrequency, nullTransactionFrequency, use } from "./utils.partial";
    import { DefinedValue } from "@Obsidian/SystemGuids/definedValue";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { Guid } from "@Obsidian/Types";
    import { ValidationResult, ValidationRuleFunction } from "@Obsidian/ValidationRules";

    const registrationEntryState = use(CurrentRegistrationEntryState);
    const { readonlyRegistrationCostSummary } = use(RegistrationCostSummary);

    const validateAmountToPayTodayRule: ValidationRuleFunction = (value: unknown, params?: unknown[]): ValidationResult => {
        if (registrationEntryState.amountToPayToday < minimumRemainingAmount.value) {
            return "must be greater than or equal to the minimum amount";
        }
        else {
            return true;
        }
    };

    //#region Values

    const isModalShown = ref<boolean>(false);
    const paymentFrequencyGuid = ref<Guid>("");
    const numberOfPayments = ref<string>("2");
    const internalDesiredAmountToPayToday = ref<number>(registrationEntryState.amountToPayToday);

    //#endregion

    //#region Computed Values

    const actualAmountDueTodayMessage = computed<string>(() => {
        let suffix = "";
        if (remainderWholeCents.value) {
            suffix = ` (${formatCurrency(remainderWholeCents.value / 100, registrationEntryState.viewModel.currencyInfo)} will be added to evenly distribute remaining payments)`;
        }
        return `${formatCurrency(registrationEntryState.amountToPayToday, registrationEntryState.viewModel.currencyInfo)}${suffix}`;
    });

    const desiredAmountToPayToday = computed<number>({
        get(): number {
            return internalDesiredAmountToPayToday.value;
        },
        set(value: number): void {
            internalDesiredAmountToPayToday.value = value;
            // Change the actual amount to pay today value. This will trigger a watcher that may update the real value.
            registrationEntryState.amountToPayToday = value;
        }
    });

    const remainderWholeCents = computed<number>(() => {
        if (numberOfPaymentsAsNumber.value === 0 || readonlyRegistrationCostSummary.value.remainingAmount === 0) {
            return 0;
        }

        return ((readonlyRegistrationCostSummary.value.remainingAmount - desiredAmountToPayToday.value) * 100) % (numberOfPaymentsAsNumber.value);
    });

    /** Gets the minimum remaining amount to be paid today, before the recurring payments, in order to get evenly split recurring payments. */
    const minimumRemainingAmount = computed<number>(() => {
        const originalMinimumRemainingAmount = readonlyRegistrationCostSummary.value.minimumRemainingAmount;
        return originalMinimumRemainingAmount;

        // if (remainderWholeCents.value !== 0) {
        //     const remainder = remainderWholeCents.value / 100;
        //     // TODO JMH This should probably be in a watch update the amountToPay.
        //     //amountToPayToday.value = amountToPayToday.value + remainder;
        //     // Add the amount necessary to make the number of payments an even number.
        //     return originalMinimumRemainingAmount + remainder;
        // }
        // else {
        //     // The remaining less the minimum amount can be evenly split into the requested number of payments.
        //     return originalMinimumRemainingAmount;
        // }
    });

    /** Gets the total amount for the registration, including paid amounts. */
    const totalAmount = computed<number>(() => {
        return readonlyRegistrationCostSummary.value.paidAmount + readonlyRegistrationCostSummary.value.remainingAmount;
    });

    /** Gets the amount per recurring payment. */
    const amountPerPayment = computed<number>(() => {
        if (numberOfPaymentsAsNumber.value === 0) {
            return 0;
        }
        else {
            return (readonlyRegistrationCostSummary.value.remainingAmount - registrationEntryState.amountToPayToday) / numberOfPaymentsAsNumber.value;
        }
    });

    /** Gets the number of payments as a number. */
    const numberOfPaymentsAsNumber = computed<number>(() => {
        return parseInt(numberOfPayments.value);
    });

    /** Gets the items for the Number of Payments drop-down control. */
    const numberOfPaymentsItems = computed<ListItemBag[]>(() => {
        if (!paymentFrequencyAsTransactionFrequency.value) {
            // A frequency must be selected to show the number of payments list.
            return [];
        }

        function getListItemBagNumberRange(start: number, stop: number): ListItemBag[] {
            stop = Math.max(start, stop);
            return Array(stop - start + 1).fill(0).map((v, i) => i + start).map(n => ({
                text: n.toString(),
                value: n.toString()
            }));
        }

        if (!paymentDeadlineDate.value) {
            // There is no deadline date, so only allow 2 to 12 payments.
            // TODO JMH What should be the allowed range here?
            return getListItemBagNumberRange(2, 12);
        }

        const maxNumberOfPayments = paymentFrequencyAsTransactionFrequency.value.getMaxNumberOfTransactionsBetweenDates(firstPaymentDate.value, paymentDeadlineDate.value);
        return getListItemBagNumberRange(2, maxNumberOfPayments);

    });

    /** Gets the first recurring payment date for the selected payment frequency. */
    const firstPaymentDate = computed<RockDateTime>(() => {
        let date: RockDateTime | undefined;

        if (paymentFrequencyAsTransactionFrequency.value) {
            date = paymentFrequencyAsTransactionFrequency.value.getNextTransactionDate();
        }

        return date ?? RockDateTime.now().date;
    });

    /** Gets the items for the payment frequency drop-down control. */
    const paymentFrequencyItems = computed<ListItemBag[]>(() => {
        // Create a copy of the array so it can be sorted.
        const items = [...registrationEntryState.viewModel.paymentPlanFrequencies ?? []];

        // Sort the frequencies.
        const rank: Record<string, number> = {
            [DefinedValue.TransactionFrequencyWeekly]: 1,
            [DefinedValue.TransactionFrequencyBiweekly]: 2,
            [DefinedValue.TransactionFrequencyFirstAndFifteenth]: 3,
            [DefinedValue.TransactionFrequencyTwicemonthly]: 4,
            [DefinedValue.TransactionFrequencyMonthly]: 5,
            [DefinedValue.TransactionFrequencyQuarterly]: 6,
            [DefinedValue.TransactionFrequencyTwiceyearly]: 7,
            [DefinedValue.TransactionFrequencyOneTime]: 8,
        };
        items.sort((a, b): number => {
            const aOrder = a.value ? rank[a.value] : -1;
            const bOrder = b.value ? rank[b.value] : -1;

            return aOrder < bOrder ? -1 : bOrder < aOrder ? 1 : 0;
        });

        return items;
    });

    /** Gets the payment deadline date as a RockDateTime. */
    const paymentDeadlineDate = computed<RockDateTime | null>(() => {
        if (!registrationEntryState.viewModel.paymentDeadlineDate) {
            return null;
        }

        return RockDateTime.parseISO(registrationEntryState.viewModel.paymentDeadlineDate);
    });

    /** Gets whether or not the payment plan feature can be shown. */
    const isShown = computed<boolean>(() => {
        if (!paymentFrequencyItems.value?.[0]?.value) {
            // There are no available frequencies so hide the feature.
            return false;
        }

        if (!paymentDeadlineDate.value) {
            // There is no payment deadline so assume the individual can make payments
            // regardless of the frequency and the deadline.
            return true;
        }

        const firstAvailableTransactionFrequency = getTransactionFrequency(paymentFrequencyItems.value[0]?.value ?? "") ?? nullTransactionFrequency;
        const startingTransactionDate = firstAvailableTransactionFrequency.getNextTransactionDate();
        const numberOfPayments = firstAvailableTransactionFrequency.getMaxNumberOfTransactionsBetweenDates(startingTransactionDate, paymentDeadlineDate.value);
        return numberOfPayments > 2;
    });

    /** Gets the selected payment frequency as a TransactionFrequency. */
    const paymentFrequencyAsTransactionFrequency = computed<TransactionFrequency>(() => {
        return getTransactionFrequency(paymentFrequencyGuid.value) ?? nullTransactionFrequency;
    });

    //#endregion

    //#region Functions

    //#endregion

    //#region Event Handlers

    //#endregion

    //#region Watchers

    watch([remainderWholeCents, desiredAmountToPayToday], ([newCents, newAmountToPay]: [number, number], [oldCents, oldAmountToPay]: [number, number]) => {
        if (newCents !== oldCents || newAmountToPay !== oldAmountToPay) {
            // Whenever amountToPayToday is changed,
            // check if it needs to be updated to another value
            // so that the amount per payment is an even number.
            if (remainderWholeCents.value !== 0) {
                // The amountToPay needs to be updated. Do it after the next render so the value has time to update.
                nextTick(() => {
                    registrationEntryState.amountToPayToday = desiredAmountToPayToday.value + (remainderWholeCents.value / 100);
                });
            }
            else {
                nextTick(() => {
                    registrationEntryState.amountToPayToday = desiredAmountToPayToday.value;
                });
            }
        }
    });

    //#endregion
</script>