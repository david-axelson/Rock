<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Modal v-model="internalIsShown"
           saveText="Select"
           title="Configure Payment Plan"
           @save="onConfigurePaymentPlan"
           @closeModal="onUnconfigurePaymentPlan">
        <div>moneyDesiredPerPaymentsRemainder {{ moneyDesiredPerPaymentsRemainder }}</div>
        <div>moneyRemainingAmount {{ moneyRemainingAmount }}</div>
        <div>moneyDesiredAmountToPayToday {{ moneyDesiredAmountToPayToday }}</div>
        <template v-if="paymentDeadlineDate">
            The total amount of {{ moneyTotalAmount }} is payable by {{ paymentDeadlineDate.toASPString("MMMM dd, yyyy") }}.
        </template>
        <template v-else>
            The total amount due is {{ moneyTotalAmount }}.
        </template>
        <div class="row">
            <div class="col">
                <DropDownList v-model="paymentFrequencyGuid"
                              :items="paymentFrequencyItems"
                              label="Select Your Desired Payment Frequency"
                              rules="required" />
            </div>
        </div>

        <div :class="['row', !paymentFrequencyGuid ? 'invisible' : '']">
            <div class="col-sm-6">
                <CurrencyBox v-model="internalDesiredAmountToPayToday"
                             label="Amount To Pay Today"
                             :rules="['required', validateAmountToPayTodayRule]">
                    <template #append>
                        <small>A minimum of {{ moneyMinimumRemainingAmount }} is due today.</small>
                    </template>
                </CurrencyBox>
            </div>

            <div class="col-sm-6">
                <DropDownList v-model="numberOfPayments"
                              :items="numberOfPaymentsItems"
                              label="Number of Payments"
                              rules="required" />
            </div>
        </div>

        <div :class="['row', !paymentFrequencyGuid ? 'invisible' : '']">
            <div class="col">
                <RockLabel label="Plan Summary">Plan Summary</RockLabel>
            </div>
        </div>

        <div :class="['row', !paymentFrequencyGuid ? 'invisible' : '']">
            <div class="col-sm-6">
                <div>Amount Due Today</div>
                <div>{{ actualAmountDueTodayMessage }}</div>
            </div>

            <div class="col-sm-6">
                <div>{{ selectedFrequencyText }} Payment Amount</div>
                <div>{{ moneyAmountPerPayment }} x {{ numberOfPaymentsAsInteger }}</div>
            </div>
        </div>
    </Modal>
</template>

<style scoped></style>

<script setup lang="ts">
    import { PropType, Ref, WritableComputedRef, computed, ref, watch } from "vue";
    import CurrencyBox from "@Obsidian/Controls/currencyBox.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import Modal from "@Obsidian/Controls/modal.obs";
    import RockLabel from "@Obsidian/Controls/rockLabel.obs";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { CurrentRegistrationEntryState, RegistrationCostSummary, TransactionFrequency, formatCurrency, getTransactionFrequency, nullTransactionFrequency, use } from "./utils.partial";
    import { DefinedValue } from "@Obsidian/SystemGuids/definedValue";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { Guid } from "@Obsidian/Types";
    import { ValidationResult } from "@Obsidian/ValidationRules";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { Money, MoneyOptions, createMoneyOptions } from "./types.partial";

    const props = defineProps({
        modelValue: {
            type: Boolean as PropType<boolean>,
            default: false,
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: boolean): void
    }>();

    const registrationEntryState = use(CurrentRegistrationEntryState);
    const { readonlyRegistrationCostSummary } = use(RegistrationCostSummary);
    const moneyOptions: MoneyOptions = createMoneyOptions({
        decimals: registrationEntryState.viewModel.currencyInfo?.decimalPlaces ?? undefined,
        symbol: registrationEntryState.viewModel.currencyInfo?.symbol ?? undefined
    });

    //#region Values

    const paymentFrequencyGuid = ref<Guid>(registrationEntryState.paymentPlanFrequencyGuid ?? "");
    const numberOfPayments = ref<string>("2");
    const internalDesiredAmountToPayToday = ref<number>(registrationEntryState.amountToPayToday);
    const moneyInProgressAmountToPayToday = ref<Money>(new Money(registrationEntryState.amountToPayToday, moneyOptions));

    //#endregion

    //#region Computed Values

    const internalIsShown = useVModelPassthrough(props, "modelValue", emit);

    const selectedFrequencyText = computed<string>(() => {
        return registrationEntryState.viewModel.paymentPlanFrequencies?.find(l => l.value === paymentFrequencyGuid.value)?.text ?? "";
    });

    const actualAmountDueTodayMessage = computed<string>(() => {
        let suffix = "";
        if (moneyDesiredPerPaymentsRemainder.value) {
            suffix = ` (${moneyDesiredPerPaymentsRemainder.value} will be added to evenly distribute remaining payments)`;
        }
        return `${moneyInProgressAmountToPayToday.value}${suffix}`;
    });

    const moneyDesiredAmountToPayToday = computed<Money>(() => new Money(internalDesiredAmountToPayToday.value, moneyOptions));

    const moneyRemainingAmount = computed<Money>(() => new Money(readonlyRegistrationCostSummary.value.remainingAmount, moneyOptions));

    const moneyDesiredPerPaymentsRemainder = computed<Money>(() => {
        if (numberOfPaymentsAsInteger.value === 0 || moneyRemainingAmount.value.isEqualTo(0)) {
            return new Money(0, moneyOptions);
        }

        // excessCents = temporarilyRemoveDec(remaining - desiredOneTimePayment) mod numberPayments
        // This is the smallest fractional unit that needs to be subtracted from the original number to be able to divide evenly by numberPayments.
        // (numberPayments - excessCents) is the smallest fractional unit that needs to be added to the original number to be able to divide evenly by numberPayments.
        return moneyRemainingAmount.value.subtract(moneyDesiredAmountToPayToday.value).mod(numberOfPaymentsAsInteger.value);
    });

    /** Gets the minimum remaining amount to be paid today, before the recurring payments, in order to get evenly split recurring payments. */
    const moneyMinimumRemainingAmount = computed<Money>(() => new Money(readonlyRegistrationCostSummary.value.minimumRemainingAmount, moneyOptions));

    /** Gets the total amount for the registration, including paid amounts. */
    const moneyTotalAmount = computed<Money>(() => {
        return new Money(readonlyRegistrationCostSummary.value.paidAmount, moneyOptions).add(new Money(readonlyRegistrationCostSummary.value.remainingAmount, moneyOptions));
    });

    /** Gets the amount per recurring payment. */
    const moneyAmountPerPayment = computed<Money>(() => {
        if (numberOfPaymentsAsInteger.value === 0) {
            return new Money(0, moneyOptions);
        }
        else {
            return new Money(readonlyRegistrationCostSummary.value.remainingAmount, moneyOptions).subtract(moneyInProgressAmountToPayToday.value).divide(numberOfPaymentsAsInteger.value).quotient;
        }
    });

    /** Gets the number of payments as a number. */
    const numberOfPaymentsAsInteger = computed<number>(() => {
        return parseInt(numberOfPayments.value);
    });

    /** Gets the items for the Number of Payments drop-down control. */
    const numberOfPaymentsItems = computed<ListItemBag[]>(() => {
        if (!paymentFrequencyAsTransactionFrequency.value) {
            // A frequency must be selected to show the number of payments list.
            return [];
        }

        function getListItemBagNumberRange(start: number, stop: number): ListItemBag[] {
            stop = Math.max(start, stop);
            return Array(stop - start + 1).fill(0).map((v, i) => i + start).map(n => ({
                text: n.toString(),
                value: n.toString()
            }));
        }

        if (!paymentDeadlineDate.value) {
            // There is no deadline date, so only allow 2 to 12 payments.
            // TODO JMH What should be the allowed range here?
            return getListItemBagNumberRange(2, 12);
        }

        const maxNumberOfPayments = paymentFrequencyAsTransactionFrequency.value.getMaxNumberOfTransactionsBetweenDates(firstPaymentDate.value, paymentDeadlineDate.value);
        return getListItemBagNumberRange(2, maxNumberOfPayments);

    });

    /** Gets the first recurring payment date for the selected payment frequency. */
    const firstPaymentDate = computed<RockDateTime>(() => {
        let date: RockDateTime | undefined;

        if (paymentFrequencyAsTransactionFrequency.value) {
            date = paymentFrequencyAsTransactionFrequency.value.getNextTransactionDate();
        }

        return date ?? RockDateTime.now().date;
    });

    /** Gets the items for the payment frequency drop-down control. */
    const paymentFrequencyItems = computed<ListItemBag[]>(() => {
        // Create a copy of the array so it can be sorted.
        const items = [...registrationEntryState.viewModel.paymentPlanFrequencies ?? []];

        // Sort the frequencies.
        const rank: Record<string, number> = {
            [DefinedValue.TransactionFrequencyWeekly]: 1,
            [DefinedValue.TransactionFrequencyBiweekly]: 2,
            [DefinedValue.TransactionFrequencyFirstAndFifteenth]: 3,
            [DefinedValue.TransactionFrequencyTwicemonthly]: 4,
            [DefinedValue.TransactionFrequencyMonthly]: 5,
            [DefinedValue.TransactionFrequencyQuarterly]: 6,
            [DefinedValue.TransactionFrequencyTwiceyearly]: 7,
            [DefinedValue.TransactionFrequencyOneTime]: 8,
        };
        items.sort((a, b): number => {
            const aOrder = a.value ? rank[a.value] : -1;
            const bOrder = b.value ? rank[b.value] : -1;

            return aOrder < bOrder ? -1 : bOrder < aOrder ? 1 : 0;
        });

        return items;
    });

    /** Gets the payment deadline date as a RockDateTime. */
    const paymentDeadlineDate = computed<RockDateTime | null>(() => {
        if (!registrationEntryState.viewModel.paymentDeadlineDate) {
            return null;
        }

        return RockDateTime.parseISO(registrationEntryState.viewModel.paymentDeadlineDate);
    });

    /** Gets the selected payment frequency as a TransactionFrequency. */
    const paymentFrequencyAsTransactionFrequency = computed<TransactionFrequency>(() => {
        return getTransactionFrequency(paymentFrequencyGuid.value) ?? nullTransactionFrequency;
    });

    //#endregion

    //#region Functions

    function validateAmountToPayTodayRule(value: unknown, params?: unknown[]): ValidationResult {
        if (moneyInProgressAmountToPayToday.value.isLessThan(moneyMinimumRemainingAmount.value)) {
            return "must be greater than or equal to the minimum amount";
        }
        else {
            return true;
        }
    }

    //#endregion

    //#region Event Handlers

    function onConfigurePaymentPlan(): void {
        // Set the values on the shared state.
        debugger; // TODO JMH How can we ensure the correct (non-rounding error) number is used here?
        registrationEntryState.amountToPayToday = Number(moneyInProgressAmountToPayToday.value.toString());
        registrationEntryState.paymentPlanFrequencyGuid = paymentFrequencyGuid.value;
        registrationEntryState.paymentPlanAmountPerPayment = Number(moneyAmountPerPayment.value.toString());
        registrationEntryState.paymentPlanNumberOfPayments = numberOfPaymentsAsInteger.value;
        registrationEntryState.paymentPlanFrequencyText = selectedFrequencyText.value;

        // Close the modal on the next tick to avoid situations where the modal cannot be reopened.
        //nextTick(() => {
        internalIsShown.value = false;
        //});
    }

    function onUnconfigurePaymentPlan(): void {
        // Don't change the values on the shared state.
        // registrationEntryState.paymentPlanFrequencyGuid = null;
        // registrationEntryState.paymentPlanAmountPerPayment = null;

        // Close the modal on the next tick to avoid situations where the modal cannot be reopened.
        //nextTick(() => {
        //    internalIsShown.value = false;
        //});
    }

    //#endregion

    //#region Watchers

    watch([moneyDesiredPerPaymentsRemainder, moneyDesiredAmountToPayToday], ([newCents, newAmountToPay]: [Money, Money], [oldCents, oldAmountToPay]: [Money, Money]) => {
        if (newCents.isNotEqualTo(oldCents) || newAmountToPay.isNotEqualTo(oldAmountToPay)) {
            // Whenever amountToPayToday is changed,
            // check if it needs to be updated to another value
            // so that the amount per payment is an even number.
            if (moneyDesiredPerPaymentsRemainder.value.isNotEqualTo(0)) {
                // The amountToPay needs to be updated. Do it after the next render so the value has time to update.
                //nextTick(() => {
                moneyInProgressAmountToPayToday.value = moneyDesiredAmountToPayToday.value.add(moneyDesiredPerPaymentsRemainder.value);
                //});
            }
            else {
                //nextTick(() => {
                moneyInProgressAmountToPayToday.value = moneyDesiredAmountToPayToday.value;
                //});
            }
        }
    });

    //#endregion
</script>