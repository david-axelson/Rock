<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Modal v-model="internalIsShown"
           saveText="Select"
           title="Configure Payment Plan"
           @save="onConfigurePaymentPlan"
           @closeModal="onUnconfigurePaymentPlan">
        <template v-if="paymentDeadlineDate">
            The total amount of {{ formatCurrency(totalAmount, registrationEntryState.viewModel.currencyInfo) }} is payable by {{ paymentDeadlineDate.toASPString("MMMM dd, yyyy") }}.
        </template>
        <template v-else>
            The total amount due is {{ formatCurrency(totalAmount, registrationEntryState.viewModel.currencyInfo) }}.
        </template>
        <div class="row">
            <div class="col">
                <DropDownList v-model="paymentFrequencyGuid"
                              :items="paymentFrequencyItems"
                              label="Select Your Desired Payment Frequency" />
            </div>
        </div>

        <div :class="['row', !paymentFrequencyGuid ? 'invisible' : '']">
            <div class="col-sm-6">
                <CurrencyBox v-model="desiredAmountToPayToday"
                             label="Amount To Pay Today"
                             :rules="validateAmountToPayTodayRule">
                    <template #append>
                        <small>A minimum of {{ formatCurrency(minimumRemainingAmount, registrationEntryState.viewModel.currencyInfo) }} is due today.</small>
                    </template>
                </CurrencyBox>
            </div>

            <div class="col-sm-6">
                <DropDownList v-model="numberOfPayments"
                              :items="numberOfPaymentsItems"
                              label="Number of Payments" />
            </div>
        </div>

        <div :class="['row', !paymentFrequencyGuid ? 'invisible' : '']">
            <div class="col">
                <RockLabel label="Plan Summary">Plan Summary</RockLabel>
            </div>
        </div>

        <div :class="['row', !paymentFrequencyGuid ? 'invisible' : '']">
            <div class="col-sm-6">
                <div>Amount Due Today</div>
                <div>{{ actualAmountDueTodayMessage }}</div>
            </div>

            <div class="col-sm-6">
                <div>{{ selectedFrequencyText }} Payment Amount</div>
                <div>{{ formatCurrency(amountPerPayment, registrationEntryState.viewModel.currencyInfo) }} x {{ numberOfPaymentsAsNumber }}</div>
            </div>
        </div>
    </Modal>
</template>

<style scoped></style>

<script setup lang="ts">
    import { PropType, computed, ref, watch } from "vue";
    import CurrencyBox from "@Obsidian/Controls/currencyBox.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import Modal from "@Obsidian/Controls/modal.obs";
    import RockLabel from "@Obsidian/Controls/rockLabel.obs";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { CurrentRegistrationEntryState, RegistrationCostSummary, TransactionFrequency, formatCurrency, getTransactionFrequency, nullTransactionFrequency, use } from "./utils.partial";
    import { DefinedValue } from "@Obsidian/SystemGuids/definedValue";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { Guid } from "@Obsidian/Types";
    import { ValidationResult } from "@Obsidian/ValidationRules";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";

    const props = defineProps({
        modelValue: {
            type: Boolean as PropType<boolean>,
            default: false,
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: boolean): void
    }>();

    const registrationEntryState = use(CurrentRegistrationEntryState);
    const { readonlyRegistrationCostSummary } = use(RegistrationCostSummary);

    //#region Values

    const paymentFrequencyGuid = ref<Guid>(registrationEntryState.paymentPlanFrequencyGuid ?? "");
    const numberOfPayments = ref<string>("2");
    const internalDesiredAmountToPayToday = ref<number>(registrationEntryState.amountToPayToday);
    const inProgressAmountToPayToday = ref<number>(registrationEntryState.amountToPayToday);

    //#endregion

    //#region Computed Values

    const internalIsShown = useVModelPassthrough(props, "modelValue", emit);

    const selectedFrequencyText = computed<string>(() => {
        return registrationEntryState.viewModel.paymentPlanFrequencies?.find(l => l.value === paymentFrequencyGuid.value)?.text ?? "";
    });

    const actualAmountDueTodayMessage = computed<string>(() => {
        let suffix = "";
        if (remainderWholeCents.value) {
            suffix = ` (${formatCurrency(remainderWholeCents.value / 100, registrationEntryState.viewModel.currencyInfo)} will be added to evenly distribute remaining payments)`;
        }
        return `${formatCurrency(inProgressAmountToPayToday.value, registrationEntryState.viewModel.currencyInfo)}${suffix}`;
    });

    const desiredAmountToPayToday = computed<number>({
        get(): number {
            return internalDesiredAmountToPayToday.value;
        },
        set(value: number): void {
            internalDesiredAmountToPayToday.value = value;
            // Change the actual amount to pay today value. This will trigger a watcher that may update the real value.
            inProgressAmountToPayToday.value = value;
        }
    });

    const remainderWholeCents = computed<number>(() => {
        if (numberOfPaymentsAsNumber.value === 0 || readonlyRegistrationCostSummary.value.remainingAmount === 0) {
            return 0;
        }

        return ((readonlyRegistrationCostSummary.value.remainingAmount - desiredAmountToPayToday.value) * 100) % (numberOfPaymentsAsNumber.value);
    });

    /** Gets the minimum remaining amount to be paid today, before the recurring payments, in order to get evenly split recurring payments. */
    const minimumRemainingAmount = computed<number>(() => {
        const originalMinimumRemainingAmount = readonlyRegistrationCostSummary.value.minimumRemainingAmount;
        return originalMinimumRemainingAmount;

        // if (remainderWholeCents.value !== 0) {
        //     const remainder = remainderWholeCents.value / 100;
        //     // TODO JMH This should probably be in a watch update the amountToPay.
        //     //amountToPayToday.value = amountToPayToday.value + remainder;
        //     // Add the amount necessary to make the number of payments an even number.
        //     return originalMinimumRemainingAmount + remainder;
        // }
        // else {
        //     // The remaining less the minimum amount can be evenly split into the requested number of payments.
        //     return originalMinimumRemainingAmount;
        // }
    });

    /** Gets the total amount for the registration, including paid amounts. */
    const totalAmount = computed<number>(() => {
        return readonlyRegistrationCostSummary.value.paidAmount + readonlyRegistrationCostSummary.value.remainingAmount;
    });

    /** Gets the amount per recurring payment. */
    const amountPerPayment = computed<number>(() => {
        if (numberOfPaymentsAsNumber.value === 0) {
            return 0;
        }
        else {
            return (readonlyRegistrationCostSummary.value.remainingAmount - inProgressAmountToPayToday.value) / numberOfPaymentsAsNumber.value;
        }
    });

    /** Gets the number of payments as a number. */
    const numberOfPaymentsAsNumber = computed<number>(() => {
        return parseInt(numberOfPayments.value);
    });

    /** Gets the items for the Number of Payments drop-down control. */
    const numberOfPaymentsItems = computed<ListItemBag[]>(() => {
        if (!paymentFrequencyAsTransactionFrequency.value) {
            // A frequency must be selected to show the number of payments list.
            return [];
        }

        function getListItemBagNumberRange(start: number, stop: number): ListItemBag[] {
            stop = Math.max(start, stop);
            return Array(stop - start + 1).fill(0).map((v, i) => i + start).map(n => ({
                text: n.toString(),
                value: n.toString()
            }));
        }

        if (!paymentDeadlineDate.value) {
            // There is no deadline date, so only allow 2 to 12 payments.
            // TODO JMH What should be the allowed range here?
            return getListItemBagNumberRange(2, 12);
        }

        const maxNumberOfPayments = paymentFrequencyAsTransactionFrequency.value.getMaxNumberOfTransactionsBetweenDates(firstPaymentDate.value, paymentDeadlineDate.value);
        return getListItemBagNumberRange(2, maxNumberOfPayments);

    });

    /** Gets the first recurring payment date for the selected payment frequency. */
    const firstPaymentDate = computed<RockDateTime>(() => {
        let date: RockDateTime | undefined;

        if (paymentFrequencyAsTransactionFrequency.value) {
            date = paymentFrequencyAsTransactionFrequency.value.getNextTransactionDate();
        }

        return date ?? RockDateTime.now().date;
    });

    /** Gets the items for the payment frequency drop-down control. */
    const paymentFrequencyItems = computed<ListItemBag[]>(() => {
        // Create a copy of the array so it can be sorted.
        const items = [...registrationEntryState.viewModel.paymentPlanFrequencies ?? []];

        // Sort the frequencies.
        const rank: Record<string, number> = {
            [DefinedValue.TransactionFrequencyWeekly]: 1,
            [DefinedValue.TransactionFrequencyBiweekly]: 2,
            [DefinedValue.TransactionFrequencyFirstAndFifteenth]: 3,
            [DefinedValue.TransactionFrequencyTwicemonthly]: 4,
            [DefinedValue.TransactionFrequencyMonthly]: 5,
            [DefinedValue.TransactionFrequencyQuarterly]: 6,
            [DefinedValue.TransactionFrequencyTwiceyearly]: 7,
            [DefinedValue.TransactionFrequencyOneTime]: 8,
        };
        items.sort((a, b): number => {
            const aOrder = a.value ? rank[a.value] : -1;
            const bOrder = b.value ? rank[b.value] : -1;

            return aOrder < bOrder ? -1 : bOrder < aOrder ? 1 : 0;
        });

        return items;
    });

    /** Gets the payment deadline date as a RockDateTime. */
    const paymentDeadlineDate = computed<RockDateTime | null>(() => {
        if (!registrationEntryState.viewModel.paymentDeadlineDate) {
            return null;
        }

        return RockDateTime.parseISO(registrationEntryState.viewModel.paymentDeadlineDate);
    });

    /** Gets the selected payment frequency as a TransactionFrequency. */
    const paymentFrequencyAsTransactionFrequency = computed<TransactionFrequency>(() => {
        return getTransactionFrequency(paymentFrequencyGuid.value) ?? nullTransactionFrequency;
    });

    //#endregion

    //#region Functions

    function validateAmountToPayTodayRule(value: unknown, params?: unknown[]): ValidationResult {
        if (inProgressAmountToPayToday.value < minimumRemainingAmount.value) {
            return "must be greater than or equal to the minimum amount";
        }
        else {
            return true;
        }
    }

    //#endregion

    //#region Event Handlers

    function onConfigurePaymentPlan(): void {
        // Set the values on the shared state.
        registrationEntryState.amountToPayToday = inProgressAmountToPayToday.value;
        registrationEntryState.paymentPlanFrequencyGuid = paymentFrequencyGuid.value;
        registrationEntryState.paymentPlanAmountPerPayment = amountPerPayment.value;
        registrationEntryState.paymentPlanNumberOfPayments = numberOfPaymentsAsNumber.value;
        registrationEntryState.paymentPlanFrequencyText = selectedFrequencyText.value;

        // Close the modal on the next tick to avoid situations where the modal cannot be reopened.
        //nextTick(() => {
        internalIsShown.value = false;
        //});
    }

    function onUnconfigurePaymentPlan(): void {
        // Don't change the values on the shared state.
        // registrationEntryState.paymentPlanFrequencyGuid = null;
        // registrationEntryState.paymentPlanAmountPerPayment = null;

        // Close the modal on the next tick to avoid situations where the modal cannot be reopened.
        //nextTick(() => {
        //    internalIsShown.value = false;
        //});
    }

    //#endregion

    //#region Watchers

    watch([remainderWholeCents, desiredAmountToPayToday], ([newCents, newAmountToPay]: [number, number], [oldCents, oldAmountToPay]: [number, number]) => {
        if (newCents !== oldCents || newAmountToPay !== oldAmountToPay) {
            // Whenever amountToPayToday is changed,
            // check if it needs to be updated to another value
            // so that the amount per payment is an even number.
            if (remainderWholeCents.value !== 0) {
                // The amountToPay needs to be updated. Do it after the next render so the value has time to update.
                //nextTick(() => {
                inProgressAmountToPayToday.value = desiredAmountToPayToday.value + (remainderWholeCents.value / 100);
                //});
            }
            else {
                //nextTick(() => {
                inProgressAmountToPayToday.value = desiredAmountToPayToday.value;
                //});
            }
        }
    });

    //#endregion
</script>