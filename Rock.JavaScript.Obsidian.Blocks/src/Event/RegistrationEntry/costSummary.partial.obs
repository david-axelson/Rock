<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Loading :isLoading="isLoading">
        <div class="fee-table">
            <div class="row hidden-xs fee-header">
                <div :class="{ 'col-sm-6': hasDiscount, 'col-sm-9': !hasDiscount }">
                    <strong>Description</strong>
                </div>
                <div class="col-sm-3 fee-value">
                    <strong>Amount</strong>
                </div>
                <div v-if="hasDiscount" class="col-sm-3 fee-value">
                    <strong>Discounted Amount</strong>
                </div>
            </div>
            <div v-for="lineItem in augmentedLineItems" class="row" :class="lineItem.isFee ? 'fee-row-fee' : 'fee-row-cost'">
                <div :class="{ 'col-sm-6 fee-caption': hasDiscount, 'col-sm-9 fee-caption': !hasDiscount }">
                    {{ lineItem.description }}
                </div>
                <div class="col-sm-3 fee-value">
                    <span class="visible-xs-inline">Amount:</span>
                    {{ `${currencyInfo.symbol} ${lineItem.amountFormatted}` }}
                </div>
                <div v-if="hasDiscount" class="col-sm-3 fee-value">
                    <HelpBlock v-if="lineItem.discountHelp" :text="lineItem.discountHelp" />
                    <span class="visible-xs-inline">Discounted Amount:</span>
                    {{ `${currencyInfo.symbol} ${lineItem.discountedAmountFormatted}` }}
                </div>
            </div>
            <div class="row fee-row-total">
                <div :class="{ 'col-sm-6 fee-caption': hasDiscount, 'col-sm-9 fee-caption': !hasDiscount }">
                    Total
                </div>
                <div class="col-sm-3 fee-value">
                    <span class="visible-xs-inline">Amount:</span>
                    {{ totalFormatted }}
                </div>
                <div v-if="hasDiscount" class="col-sm-3 fee-value">
                    <span class="visible-xs-inline">Discounted Amount:</span>
                    {{ discountedTotalFormatted }}
                </div>
            </div>
        </div>
        <div class="row fee-totals">
            <div class="col-sm-offset-8 col-sm-4 fee-totals-options">
                <StaticFormControl v-model="discountedTotalFormatted" label="Total Cost" />
                <StaticFormControl v-if="amountPreviouslyPaid" v-model="amountPreviouslyPaidFormatted" label="Previously Paid" />
                <template v-if="showAmountDueToday && maxAmountCanBePaid">
                    <StaticFormControl v-model="amountDueTodayFormatted" label="Minimum Due Today" />
                    <ConfigurePaymentPlanModal v-model="isConfigurePaymentPlanModalShown" />
                    <template v-if="!isPaymentPlanConfigured">
                        <CurrencyBox label="Amount To Pay Today" :rules="amountToPayTodayRules" v-model="registrationEntryState.amountToPayToday" formGroupClasses="form-right" inputGroupClasses="input-width-md amount-to-pay" />
                        <StaticFormControl v-model="amountRemainingFormatted" label="Amount Remaining After Payment" />
                        <div class="form-group">
                            <RockButton btnType="default" btnSize="xs" @click="onConfigurePaymentPlanClicked">Configure a Payment Plan</RockButton>
                        </div>
                        <br />
                    </template>
                    <template v-else>
                        <div class="payment-plan well">
                            <RockLabel class="primary-label">Payment Plan</RockLabel>
                            <StaticFormControl label="Amount Due Today" :modelValue="formatCurrency(registrationEntryState.amountToPayToday, registrationEntryState.viewModel.currencyInfo)" />
                            <StaticFormControl :label="`${registrationEntryState.paymentPlanFrequencyText} Payment Amount`" :modelValue="`${formatCurrency(registrationEntryState.paymentPlanAmountPerPayment ?? 0, registrationEntryState.viewModel.currencyInfo)} x ${registrationEntryState.paymentPlanNumberOfPayments ?? 0}`" />
                            <RockButton btnType="default" btnSize="xs" @click="onConfigurePaymentPlanClicked">Change</RockButton>
                            <RockButton btnType="link" btnSize="xs" @click="onUnconfigurePaymentPlanClicked">Cancel</RockButton>
                        </div>
                    </template>
                </template>
                <StaticFormControl v-else v-model="maxAmountCanBePaidFormatted" label="Amount Due" />
            </div>
        </div>
    </Loading>
</template>

<style scoped>
.payment-plan :deep(.control-label:not(.primary-label)) {
    font-weight: normal;
}
</style>

<script setup lang="ts">
    import { computed, nextTick, ref, watch } from "vue";
    import { GetPersistSessionArgs, CurrentRegistrationEntryState, use, RegistrationCostSummary, formatCurrency } from "./utils.partial";
    import CurrencyBox from "@Obsidian/Controls/currencyBox.obs";
    import HelpBlock from "@Obsidian/Controls/helpBlock.obs";
    import Loading from "@Obsidian/Controls/loading.obs";
    import StaticFormControl from "@Obsidian/Controls/staticFormControl.obs";
    import { useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { ValidationRule } from "@Obsidian/ValidationRules";
    import { RegistrationEntryCostSummaryBag } from "@Obsidian/ViewModels/Blocks/Event/RegistrationEntry/registrationEntryCostSummaryBag";
    import { CurrencyInfoBag } from "@Obsidian/ViewModels/Utility/currencyInfoBag";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import ConfigurePaymentPlanModal from "./configurePaymentPlanModal.partial.obs";
    import RockLabel from "@Obsidian/Controls/rockLabel.obs";

    enum RegistrationCostSummaryType {
        Cost = 0,
        Fee = 1,
        Discount = 2,
        Total = 3
    }

    type AugmentedLineItem = RegistrationEntryCostSummaryBag & {
        isFee: boolean;
        discountHelp: string;
        discountedAmountFormatted: string;
        amountFormatted: string;
    };

    const getRegistrationEntryBlockArgs = use(GetPersistSessionArgs);
    const invokeBlockAction = useInvokeBlockAction();
    const registrationEntryState = use(CurrentRegistrationEntryState);
    const { updateRegistrationCostSummary } = use(RegistrationCostSummary);

    // #region Values

    const isLoading = ref<boolean>(false);
    const lineItems = ref<RegistrationEntryCostSummaryBag[]>([]);
    const isConfigurePaymentPlanModalShown = ref<boolean>(false);
    const isPaymentPlanConfigured = ref<boolean>(!!registrationEntryState.paymentPlanNumberOfPayments && !!registrationEntryState.paymentPlanAmountPerPayment);
    watch([() => registrationEntryState.paymentPlanFrequencyGuid, () => registrationEntryState.paymentPlanAmountPerPayment, () => registrationEntryState.paymentPlanNumberOfPayments], () => {
        isPaymentPlanConfigured.value = !!registrationEntryState?.paymentPlanNumberOfPayments && !!registrationEntryState.paymentPlanAmountPerPayment;
    });

    // #endregion

    // #region Computed Values

    /** TODO JMH Gets whether or not the payment plan feature can be shown. */
    // const isPaymentPlanConfigurationSupported = computed<boolean>(() => {
    //     if (!paymentFrequencyItems.value?.[0]?.value) {
    //         // There are no available frequencies so hide the feature.
    //         return false;
    //     }

    //     if (!paymentDeadlineDate.value) {
    //         // There is no payment deadline so assume the individual can make payments
    //         // regardless of the frequency and the deadline.
    //         return true;
    //     }

    //     const firstAvailableTransactionFrequency = getTransactionFrequency(paymentFrequencyItems.value[0]?.value ?? "") ?? nullTransactionFrequency;
    //     const startingTransactionDate = firstAvailableTransactionFrequency.getNextTransactionDate();
    //     const numberOfPayments = firstAvailableTransactionFrequency.getMaxNumberOfTransactionsBetweenDates(startingTransactionDate, paymentDeadlineDate.value);
    //     return numberOfPayments > 2;
    // });

    const currencyInfo = computed<CurrencyInfoBag>(() => {
        console.log("currencyInfo", registrationEntryState.viewModel.currencyInfo);
        return registrationEntryState.viewModel.currencyInfo ?? {
            decimalPlaces: 2,
            symbol: "$"
        };
    });

    /** Line items with some extra info computed for table rendering */
    const augmentedLineItems = computed<AugmentedLineItem[]>(() => {
        return lineItems.value.map(li => ({
            ...li,
            isFee: li.type === RegistrationCostSummaryType.Fee,
            discountHelp: (hasDiscount.value && li.cost === li.discountedCost) ? "This item is not eligible for the discount." : "",
            // Ignore the currency symbol when formatting.
            // It will be prepended with a space in the template.
            amountFormatted: formatCurrency(li.cost, { symbol: "" }),
            discountedAmountFormatted: formatCurrency(li.discountedCost, { symbol: "" })
        } as AugmentedLineItem));
    });

    /** Should the discount column in the fee table be shown? */
    const hasDiscount = computed<boolean>(() => {
        return lineItems.value.some(li => li.discountedCost !== li.cost);
    });

    /** The total cost before discounts */
    const total = computed<number>(() => {
        let total = 0;
        lineItems.value.forEach(li => total += li.cost);
        return total;
    });

    /** The total before discounts as a formatted string */
    const totalFormatted = computed<string>(() => {
        return formatCurrency(total.value);
    });

    /** The total cost before discounts */
    const defaultPaymentAmount = computed<number>(() => {
        let total = 0;
        let hasDefault = false;

        lineItems.value.forEach(li => {
            if (li.defaultPaymentAmount) {
                hasDefault = true;
                total += li.defaultPaymentAmount;
            }
        });

        total = hasDefault ? total : maxAmountCanBePaid.value;

        if (total > maxAmountCanBePaid.value) {
            total = maxAmountCanBePaid.value;
        }

        if (total < amountDueToday.value) {
            total = amountDueToday.value;
        }

        if (total < 0) {
            total = 0;
        }

        return total;
    });

    /** The total cost after discounts */
    const discountedTotal = computed<number>(() => {
        let total = 0;
        lineItems.value.forEach(li => total += li.discountedCost);
        return total;
    });

    /** The total after discounts as a formatted string */
    const discountedTotalFormatted = computed<string>(() => {
        return formatCurrency(discountedTotal.value);
    });

    /** The min amount that must be paid today */
    const amountDueToday = computed<number>(() => {
        if (amountPreviouslyPaid.value) {
            return 0;
        }

        let total = 0;
        lineItems.value.forEach(li => total += (Math.min(li.minimumPaymentAmount, li.discountedCost)));
        return total;
    });

    /** The min amount that must be paid today as a formatted string */
    const amountDueTodayFormatted = computed<string>(() => {
        return formatCurrency(amountDueToday.value);
    });

    /** Should the amount that is due today be shown */
    const showAmountDueToday = computed<boolean>(() => {
        return amountDueToday.value !== discountedTotal.value;
    });

    /** The amount previously paid */
    const amountPreviouslyPaid = computed<number>(() => {
        return registrationEntryState.viewModel.session?.previouslyPaid || 0;
    });

    /** The amount previously paid formatted as a string */
    const amountPreviouslyPaidFormatted = computed<string>(() => {
        return formatCurrency(amountPreviouslyPaid.value);
    });

    /** The max amount that can be paid today */
    const maxAmountCanBePaid = computed<number>(() => {
        const balance = discountedTotal.value - amountPreviouslyPaid.value;

        if (balance > 0) {
            return balance;
        }
        return 0;
    });

    /** The max amount that can be paid today as a formatted string */
    const maxAmountCanBePaidFormatted = computed<string>(() => {
        return formatCurrency(maxAmountCanBePaid.value);
    });

    /** The amount that would remain if the user paid the amount indicated in the currency box */
    const amountRemaining = computed<number>(() => {
        const actual = maxAmountCanBePaid.value - registrationEntryState.amountToPayToday;
        const bounded = actual < 0 ? 0 : actual > maxAmountCanBePaid.value ? maxAmountCanBePaid.value : actual;
        return bounded;
    });

    /** The amount that would remain if the user paid the amount indicated in the currency box as a formatted string */
    const amountRemainingFormatted = computed<string>(() => {
        return formatCurrency(amountRemaining.value);
    });

    /** The vee-validate rules for the amount to pay today */
    const amountToPayTodayRules = computed<ValidationRule[]>(() => {
        const rules: ValidationRule[] = [];
        let min = amountDueToday.value;
        const max = maxAmountCanBePaid.value;

        if (min > max) {
            min = max;
        }

        if (min > 0) {
            rules.push("required");
        }
        else {
            rules.push("notblank");
        }

        rules.push(`gte:${min}`);
        rules.push(`lte:${max}`);

        return rules;
    });

    // #endregion

    // #region Functions

    /** Retrieve the line item costs from the server */
    async function fetchData(): Promise<void> {
        isLoading.value = true;
        lineItems.value = [];

        try {
            const response = await invokeBlockAction<RegistrationEntryCostSummaryBag[]>("CalculateCost", {
                args: getRegistrationEntryBlockArgs()
            });

            if (response.data) {
                lineItems.value = response.data;
            }
        }
        finally {
            isLoading.value = false;
        }

        // Update the shared registration cost data.
        updateRegistrationCostSummary({
            paidAmount: amountPreviouslyPaid.value,
            remainingAmount: amountRemaining.value,
            minimumRemainingAmount: amountDueToday.value
        });
    }

    // #endregion

    // #region Event Handlers

    function onConfigurePaymentPlanClicked(): void {
        console.debug(`costSummary: onConfigurePaymentPlanClicked(); // Old value: ${isConfigurePaymentPlanModalShown.value}`);
        // Open the modal on the next tick to avoid situations where the modal cannot be reopened.
        nextTick(() => {
            isConfigurePaymentPlanModalShown.value = true;
        });
    }

    function onUnconfigurePaymentPlanClicked(): void {
        console.debug(`costSummary: onUnconfigurePaymentPlanClicked(); // Old value: ${isConfigurePaymentPlanModalShown.value}`);
        // Open the modal on the next tick to avoid situations where the modal cannot be reopened.
        registrationEntryState.paymentPlanAmountPerPayment = null;
        registrationEntryState.paymentPlanFrequencyGuid = null;
    }

    // #endregion

    // #region Watchers

    watch(defaultPaymentAmount, () => {
        registrationEntryState.amountToPayToday = defaultPaymentAmount.value;
    }, {
        immediate: true
    });

    watch(() => registrationEntryState.discountCode, async (): Promise<void> => {
        await fetchData();
    });

    // #endregion

    fetchData();
</script>